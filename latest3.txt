import datetime
import calendar
import json
import os
import requests
import difflib

DATA_FILE = 'tasks.json'
users = {}
current_user = None

def save_data():
    def serializer(obj):
        if isinstance(obj, datetime.date):
            return obj.isoformat()
        if isinstance(obj, datetime.time):
            return obj.strftime("%H:%M:%S")
        return str(obj)

    with open(DATA_FILE, 'w') as f:
        json.dump(users, f, default=serializer)

def load_data():
    global users
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, 'r') as f:
            raw_data = json.load(f)
            for user, data in raw_data.items():
                users[user] = {'tasks': []}
                for task in data['tasks']:
                    if 'due_date' in task:
                        task['due_date'] = datetime.datetime.strptime(task['due_date'], "%Y-%m-%d").date()
                    if 'due_time' in task and task['due_time']:
                        task['due_time'] = datetime.datetime.strptime(task['due_time'], "%H:%M:%S").time()
                    users[user]['tasks'].append(task)

def correct_day_name(input_str):
    corrections = {
        "thurday": "Thursday",
        "wensday": "Wednesday",
        "wednasday": "Wednesday",
        "tuesaday": "Tuesday",
        "tommarow": "tomorrow",
        "tomarow": "tomorrow"
    }
    normalized = input_str.lower().strip()
    if normalized in corrections:
        return corrections[normalized]

    day_keywords = list(calendar.day_name) + ["today", "tomorrow"]
    matches = difflib.get_close_matches(normalized, day_keywords, n=1, cutoff=0.6)
    return matches[0] if matches else None

def get_next_weekday(weekday):
    today = datetime.date.today()
    days_ahead = (weekday - today.weekday() + 7) % 7
    if days_ahead == 0:
        days_ahead = 7
    return today + datetime.timedelta(days=days_ahead)

def parse_date_input(date_str):
    corrected = correct_day_name(date_str)
    if corrected == "today":
        return datetime.date.today()
    elif corrected == "tomorrow":
        return datetime.date.today() + datetime.timedelta(days=1)
    elif corrected in calendar.day_name:
        return get_next_weekday(list(calendar.day_name).index(corrected))
    try:
        return datetime.datetime.strptime(date_str, "%m/%d/%Y").date()
    except ValueError:
        return None

def show_todo_list():
    print("\nTo-do:")
    today = datetime.date.today()
    sorted_tasks = sorted(users[current_user]['tasks'], key=lambda x: x['due_date'])
    for i, task in enumerate(sorted_tasks):
        due_date = task['due_date']
        color = task.get('color', 'none')
        days_left = (due_date - today).days
        time_str = f" at {task['due_time'].strftime('%I:%M %p')}" if 'due_time' in task else ""
        print(f"{i+1}. {task['name']} {calendar.day_name[due_date.weekday()]} {due_date.strftime('%m/%d/%Y')}{time_str} ({days_left} days left) - Description: {color}")

def find_task(identifier):
    if identifier.isdigit():
        idx = int(identifier) - 1
        if 0 <= idx < len(users[current_user]['tasks']):
            return idx
    for i, task in enumerate(users[current_user]['tasks']):
        if task['name'].lower() == identifier.lower():
            return i
    return None

def show_commands():
    commands = {
        "add": "Add a new task.",
        "color": "Assign a description to a task.",
        "commands": "List all available commands.",
        "coords": "Display current coordinates and address.",
        "date": "Display the current date.",
        "fin": "Finish (delete) a task.",
        "gps_info": "Show GPS access requirements and explanation.",
        "list": "Display all tasks sorted by due date.",
        "ndate": "Set a new date (MM/DD/YYYY).",
        "new_user": "Create and switch to a new user.",
        "time_add": "Add a due time to an existing task.",
        "user": "Switch to an existing user."
    }
    print("\nAvailable Commands:")
    for command in sorted(commands.keys()):
        print(f"[{command}] - {commands[command]}")

def get_location_info():
    print("\nNote: This is IP-based and may not reflect exact GPS coordinates.\n")
    try:
        response = requests.get("https://ipinfo.io/json")
        data = response.json()
        loc = data.get("loc", "0,0")
        city = data.get("city", "Unknown city")
        region = data.get("region", "Unknown region")
        country = data.get("country", "Unknown country")
        org = data.get("org", "Unknown org")
        zip_code = data.get("postal", "Unknown postal")

        lat, lon = loc.split(',')
        print(f"Latitude: {lat}, Longitude: {lon}")
        print(f"Approximate Address: {city}, {region}, {zip_code}, {country}")
        print(f"ISP / Organization: {org}")
    except Exception as e:
        print("Error getting location:", e)

def main():
    global current_user
    load_data()
    current_user = input("User: ").strip()
    if current_user not in users:
        users[current_user] = {'tasks': []}

    while True:
        command = input("execute: ").strip().lower()

        if command == "date":
            print("Current date:", datetime.date.today().strftime("%m/%d/%Y"))
        elif command == "ndate":
            new_date = input("Enter new date (MM/DD/YYYY): ")
            try:
                new_date_obj = datetime.datetime.strptime(new_date, "%m/%d/%Y").date()
                print("New date set to:", new_date_obj.strftime("%m/%d/%Y"))
            except ValueError:
                print("Invalid date format.")
        elif command == "add":
            task_name = input("New task: ").strip()
            due_input = input(f"When is '{task_name}' due? (weekday, MM/DD/YYYY, today, or tomorrow): ").strip()
            due_date = parse_date_input(due_input)
            if not due_date:
                print("Invalid due date.")
                continue
            users[current_user]['tasks'].append({
                'name': task_name,
                'due_date': due_date
            })
            print(f"Task '{task_name}' added for {due_date.strftime('%m/%d/%Y')}.")
            save_data()
        elif command == "time_add":
            task_id = input("For which task? (name or number): ").strip()
            task_index = find_task(task_id)
            if task_index is None:
                print("Task not found.")
                continue
            time_str = input("What time is it due? (e.g., 3:00 PM): ").strip()
            try:
                due_time = datetime.datetime.strptime(time_str, "%I:%M %p").time()
                users[current_user]['tasks'][task_index]['due_time'] = due_time
                print(f"Time added to task at {due_time.strftime('%I:%M %p')}")
                save_data()
            except ValueError:
                print("Invalid time format.")
        elif command == "list":
            if not users[current_user]['tasks']:
                print("No tasks to show.")
            else:
                show_todo_list()
        elif command == "fin":
            task_to_remove = input("Which task to delete? (name or number): ").strip()
            index = find_task(task_to_remove)
            if index is not None:
                removed = users[current_user]['tasks'].pop(index)
                print(f"Removed: {removed['name']}")
                save_data()
            else:
                print("Task not found.")
        elif command == "color":
            task_id = input("For which task? (name or number): ").strip()
            task_index = find_task(task_id)
            if task_index is None:
                print("Task not found.")
                continue
            color = input("Add description:   ").strip().lower()
            users[current_user]['tasks'][task_index]['color'] = color
            print(f"Assigned description to task.")
            save_data()
        elif command == "coords":
            get_location_info()
        elif command == "gps_info":
            print(
                "\nGPS Access Requirements:\n"
                "- Accurate location requires a GPS-enabled device.\n"
                "- On desktop computers, this is not usually available.\n"
                "- Mobile apps or web apps can request accurate GPS access.\n"
            )
        elif command == "commands":
            show_commands()
        elif command == "new_user":
            new_username = input("New user name: ").strip()
            if new_username in users:
                print("User already exists.")
            else:
                users[new_username] = {'tasks': []}
                current_user = new_username
                print("Switched to new user.")
        elif command == "user":
            switch_to = input("Switch to user: ").strip()
            if switch_to in users:
                current_user = switch_to
                print(f"Switched to {switch_to}")
            else:
                print("User not found.")
        else:
            print("Unknown command. Type 'commands' to see available commands.")

if __name__ == "__main__":
    main()
